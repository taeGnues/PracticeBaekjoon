import sys
# 회전 대칭 가능.

N, M = map(int, sys.stdin.readline().split())
bd = [list(map(int, sys.stdin.readline().split())) for _ in range(N)]

tetros = [
    [(0,0), (1,0), (2,0), (3,0)], # [][][][] 세로
    [(0,0), (0,1), (0,2), (0,3)], # [][][][] 가로

    [(0,0), (0,1), (1,0), (1,1)], # []-[]-[]-[] 정사각형

    [(0,0), (1,0), (2,0), (2,1)], # [][][]-[]
    [(0,0), (1,0), (0,1), (0,2)], # []-[][][]
    [(0,0), (0,1), (1,1), (2,1)], # []-[][][]
    [(0,0), (0,1), (0,2), (-1,2)], # [][][]-[]
    [(0,0), (0,1), (1,0), (2,0)], # [][]-[][]
    [(0,0), (1,0), (1,1), (1,2)],
    [(0,0), (0,1), (-1,1), (-2,1)],
    [(0,0), (0,1), (0,2), (1,2)],

    [(0,0), (0,1), (1,1), (0,2)], #[] [[]] []
    [(0,0), (0,1), (-1,1), (0,2)],
    [(0,0), (1,0), (1,1), (2,0)],
    [(0,0), (1,0), (1,-1), (2,0)],

    [(0,0), (1,0), (1,1), (2,1)],
    [(0,0), (1,0), (1,-1), (2,-1)],
    [(0,0), (0,1), (-1,1), (-1,2)],
    [(0,0), (0,1), (1,1), (1,2)]

]

def go(sx, sy): # 한점에서 시작하는 모든 테트로미노를 대입해보고, 그 중 최대합이 나오는 것을 선택.
    res = 0
    for tetro in tetros:
        tmp = 0
        for t in tetro:
            nx = sx+t[0]
            ny = sy+t[1]

            if nx < 0 or ny < 0 or nx >= N or ny >= M:
                tmp = 0 # 블럭이 하나라도 범위 벗어나면 무시.
                break

            tmp+=bd[nx][ny]
        
        res = max(tmp, res)
    return res


ans = 0
for i in range(N):
    for j in range(M):
        ans = max(go(i,j), ans)

print(ans)